Реализовать все 4 схемы (на 4 схеме мультипротоколирование и TCP и UDP. 
Мультиплексирование добавлять не стоит).

Клиент запрашивает время, сервер возвращает его клиенту.
+
к этому надо написать программу тестироващик с множеством клиентов. 
Провести нагрузочное тестирование.

1 Схема. Параллельный сервер. Создание потоков.
Есть слущающий сервер, адрес и порт которого известы. 
Слушающий сервер плодит потоки для подключающихся клиентов.
TCP: Слушающий сервер выделяет для клиента сокет через accept и передает его в поток.
UDP: accept не сработает. Нужно искать порт самому и создавать сокет 
самому.

При подключении клиента к серверу, сервер создает поток и уже он 
работает с клиентом.

2 Схема. Параллельный сервер. Пул потоков.
Так же и схема 1, но есть созданное количество потоков с серверами.
Слушающий сервер знает какие сервера сейчас свободны, перенаправляет 
на него клиента.
Сервера говорят об освобождении по IPC.

3 Схема. "Очередь" для слушающего сервера.
Используется "очередь", в качестве очереди выступает любая стуктура
накапливающая данные. 
Клиенты присоединяются к слушающему серверу. Сл. сервер ставит в очередь
информацию о подключении клиента. 
Обслуживающие сервера берут эту информацию и обрабатывают клиента.
Слушающий сервер освобождается и обслуживает  следующего клиента.
Слушающий сервер выступает в роли регулировщика.

4 Схема. мультипротоколирование. 
select
poll
epoll - Роберт Лав, читать.

Потоки делать не надо, суть в том, чтобы создать на каждого клиента 
по файловому дискриптору и с помощью функций выше работать с TCP и UDP.
Соответственно надо написать двух клиентов под TCP и UDP

ПАПКИ С ЗАДАНИЯМИ: Shemas
